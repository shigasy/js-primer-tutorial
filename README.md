# js-primer-tutorial

## 値の評価と表示
- ブラウザのREPLで`shift + enter`で複数行入力出来る。

- ウェブページリロードでREPLの実行状態をリセット
- 自動表示はREPLの機能
- // => 評価結果 という書き方は良さそう

## データ型とリテラル
- オブジェクト型とは、複数のプリミティブ型の値またはオブジェクトからなる集合のこと
- オブジェクト型は参照型
- typeof演算子はプリミティブ型とオブジェクト型かを判定するもの。オブジェクトの詳細な種類を判定できない
- "" や '' や `` はすべて文字列型。 ""や''は改行したい場合、\nが必要。テンプレートリテラルは\nが必要ない。
- リテラルとは、プログラム上で数値や文字列など、データ型の値を直接記述できるように構文として定義されたもの。 {}はオブジェクトリテラル -> オブジェクトとしてデータ型を定義できる
- undefinedはただのグローバル変数でundefinedという値を持っているだけ。true や false、 nullはリテラルであるため、同じ名前の変数を定義できない。
- オブジェクト型のドット記法は変数名と同じく識別子である必要があるため、数値から始める識別子は利用できない
- / /とスラッシュで囲むと正規表現リテラル。正規表現のデータ型になる。（オブジェクト）
- 明示的にラッパーオブジェクトを使う理由はない。JavaScriptではプリミティブ型のデータに対してもオブジェクトのように参照できる仕組みがあるから。（lengthプロパティにアクセスできる）
  - プリミティブ型のデータのプロパティにアクセスする際に、対応するラッパーオブジェクトへの暗黙的に変換してプロパティにアクセスするから。

## 演算子
- 演算子の対象のことを被演算子（オペランドと呼ぶ）オペランド1 演算子 オペランド2
- 単項演算子と二項演算子
- ** べき乗演算子はES2016から
- NaNはNot a Numberの略で数値ではないがNumber型を表現。NaNはどの値とも一致しない特性があり、Number.isNaNメソッドでNaNを判定できる
- インクリメント演算子
  - 前置の場合 num++
    1. numの評価結果を返す
    2. numに対して+1する
  - 後置の場合 ++num
    1. numに対して+1する
    2. numの評価結果を返す
- === 厳密等価演算子は同じ型で同じ値である場合にtrueを返す
  - オブジェクト同士の場合、参照が同じである場合にtrueを返す
- == 等価演算子はオペランド同士が異なる方の値であった場合に、同じ型となるように暗黙的な型変換をしてから比較するため、予測できない挙動が多く存在する。
- null と undefinedの比較の場合、 == で判定出来るため、1度の比較でよくなる。これは例外的なケースであるため、仕組みを理解するまでは常に厳密等価演算子を利用することを推奨。
- ~ 否定演算子は1の補数を返すため、~indexOfメソッドを使ったイディオムが一部では使われていた。
- 代入演算子は二項演算子と組み合わせて利用できる /= *= &=
- 論理演算子の短絡評価は便利だよね〜 x || y で xがtrueだったらyが評価されずにyを返すやつ。 && も似たような感じ。
  - ES2020からnullish coalescing operator使えば、falsyな値でも null or undefinedの場合のみデフォルトの値を返すようになる。
- 安易に!!によるbool変換に頼るより、明示的に出来る方法 str.length > 0 などにした方が可動性高まる

## 暗黙的な型変換
- Booleanコンストラクター関数を使うことで、任意の値をtrueまたはfalseの真偽値に変換できる。REPLでさっと検証できそう
- 暗黙的な型変換より、明示的な型変換
- 明示的に変換でも解決しないことがある（NaNなど） 例外処理や型を付けるなど解決策はある。そもそも受け付けなければOK
- 空文字判定など、型変換以外の方法もある（.length === 0）

## 関数と宣言
- ES2015でデフォルと引数が導入されるまでは、OR演算子を使ったデフォルト値の指定がよく利用されていた prefix || "デフォルト"
  - ただし、falsyな値の場合、デフォルト値になるため、""（空文字列）を指定した場合にもデフォルト値が入る。意図した挙動なのかわかりにくくなる
  - デフォルト引数は、引数が渡されなかった場合のみデフォルト値が入る
- Rest parameters（残余引数） function fn(...args)  に配列を展開して関数の引数に渡すSpread構文もある fn(...array)
- 可変用引数を実現したい時にarguments変数よりRest parametersでの実装を推奨
- 関数の引数においても分割代入が利用できる。これ初見読めなかった。
```javascript
const user = {
  id: 42
};
function printUserId({ id }) {
  console.log(id)
}
printUserId(user)
```
- 関数の引数における分割代入は、オブジェクトだけでなく配列についても利用できる
```javascript
function print([first, second]){

}
const array = [1, 2]
print(array)
```
- 関数はオブジェクトの1種。ただのオブジェクトと異なり、関数名に（）をつけることで、関数としてまとめた処理を呼び出せる。オブジェクトであるため、定義した関数を変数へ代入できる。関数が値として扱えることを第一級関数（ファーストクラスファンクション）と呼ぶ。
- 関数式とは、関数を値として代入している式の事。関数宣言は文だったが、関数式では関数を値として扱っている。
- Arrow Functionの特徴
  - thisが静的
  - 常に匿名関数（functionの関数式の場合、名前をつけられて、再帰的な処理も書くことができる）
  - arguments変数を参照できない
  - functionキーワードに比べて短く書くことが出来る
  - newできない（コンストラクタ関数ではない）
- Arrow Functionはfunctionキーワードと比べて、thisの問題を多く解決したり、arguments変数が使えないため、人による解釈や実装の違いが生まれにくいため、問題ない場合はArrow Functionで書くことを推奨。
- 同じ名前の関数宣言は上書きされる。varと同じ。これはJavaScriptの巻き上げによるものだと思う。同じ名前にすることは基本的に避けるべきであり、引数の数で関数を分けたい場合は、別々の名前 or 関数内部で引数の処理を分岐
- ES2015からメソッドの短縮記法がある。オブジェクトリテラルの中でメソッド名() {} と書くことが出来る
```javascript
const obj = {
  method() {
    return 'this is method';
  }
}
console.log(obj.method())
```
- 関数文と関数式の違いは巻き上げの有無と匿名関数が可能くらいかな。コールバック関数として関数文も使えたし。
- functionキーワードとArrow functionは割と違う

## 文と式
- 式とは、値を生成し、変数に代入できるもの
- 文とは、処理する1ステップが1つの文

- ブロック文を使うと、REPLで試行錯誤しやすい（スコープが限定されるため、同じ変数でconst let宣言できる）
- JavaScriptは文（Statement）と式（Expression）から構成される
- 文は式になれない（if文や関数宣言は変数に入れられない（関数式は別））
- 式は文になれる（式文）
- 式の末尾にはセミコロン
- 文の処理の一部として式を含むことがある（if文の条件の所は式）
- ブロックで終わる文は例外的にセミコロンをつけなくてよい

## 条件分岐
- 1行のときのみ {} ブロック省略できるが、どこまでがif文かが分かりにくくなるため、常にブロックで囲むことを推奨
- if文の条件式にtrueまたはfalseといった真偽値以外の値も指定可能。真偽値以外の値の場合、暗黙的に真偽値に変換して条件式で判定
- break;を忘れると意図しないcase節が実行されてしまうため、多用されているswitch文が出てきた場合、別の方法で書けないかを考えるべきサイン。returnを返すパターンが多い。（break要らない）

## ループと反復処理
- 無限ループはブラウザの場合、ページまたはブラウザそのものを閉じることで強制終了。Nodeは終了シグナル（ctrl + c）で強制停止
- 引数として渡される関数のことをコールバック関数と呼ぶ。
  - コールバック関数メリット: 渡す関数だけ変えて、ロジックだけを変更していくことが可能。柔軟な関数
- コールバック関数を引数として受け取る関数やメソッドのことを高階関数と呼ぶ（戻り値もあったはず）
  - 高階関数メリット: ロジックを使い回すことができ、コードも短くて何をしているのか見通しが良くなること
- 配列のメソッド
  - forEach 配列の要素数だけ反復処理 -> lengthでfor回す記法などを短縮できる
  - some 一度でもtrueを返した時点で反復終了 -> break;やreturnで処理を終わらせる記法などを短縮できる
  - filter 絞り込み trueを返した要素のみの新しい配列を返す -> continueで新しい配列を作る記法などを短縮できる。
- for...inは避ける。親オブジェクトまで列挙可能なものがあるか探索して列挙するため、意図しない結果になる。安全にオブジェクトを列挙するにはObject.keysメソッド、values、entriesを使う
- ES2015からfor...of文が書けるようになった。iterable（反復可能）。（pythonの場合、inで書くやつ）
  - 反復可能な王bジェクトはIterable
  - IterableなオブジェクトはIteratorを持つ
  - for...of文で簡単にIterableを反復処理できる
  - Symbol.iteratorで返す関数を書けば自作することも可能
- forのインクリメントする場合、let。for...ofなどはループの度にブロックで囲まれて実行される。そのためconstで宣言。https://github.com/asciidwango/js-primer/issues/567

## オブジェクト
- オブジェクトのプロパティ名はは`""`や`'`を省略できるが、変数の識別子として利用できないプロパティは`""`や`'`で囲む必要がある。
  - 変数の識別子として利用できないのであれば、ドット記法でも呼び出せない
- ES2015からプロパティ名と変数名が同じであれば省略できる
```javascript
const name = "名前"
const obj = {
  name
}
```
- プロパティを初期化時以外に追加してしまうと、そのオブジェクトがどのようなプロパティを持っているかが分かりにくくなる。できる限り作成後に新しいプロパティは追加しない。
- Object.freezeを使うと、プロパティの変更や追加を行おうとすると例外が発生する。ただし、strict modeと合わせて使わないと、無視される
- プロパティ名が間違えていた場合にも、例外が発生しない。さらにプロパティ名をネストしてアクセスした場合に、はじめて例外が発生する。
  - undefinedで比較すると、プロパティの値がundefinedの可能性があるため、keyがないのか、プロパティ名がundefinedか分からない問題
  - in演算子かhasOwnPropertyを使う
  - 厳密には違うからプロトタイプオブジェクト章で解説
```javascript
const obj = { key: undefined };
// `key`プロパティを持っているならtrue
if ("key" in obj) {
    console.log("`key`プロパティは存在する");
}
if (obj.hasOwnProperty("key")) {
    console.log("`object`は`key`プロパティを持っている");
}
```
- [ES2015] Object.assignは第一引数に空の配列を指定して既存のオブジェクトに影響を与えずにマージするのが典型的な利用方法
```javascript
const merged = Object.assign({}, objectA, objectB);
```
```javascript
// 既存のオブジェクトに追加する場合。
// objectAの値が変わる
const merge = Object.assign(objectA, objectB)
```


- [ES2018] オブジェクトに対するspread構文が追加された。必ず新しいオブジェクトを生成する。spread構文はオブジェクトリテラルの中でのみ記述でき、オブジェクトリテラルは新しいオブジェクトを作成するから。
```javascript
const objectA = { a: "a" }
const objectB = { b: "b" }
const merged = {
  ...objectA,
  ...objectB
}
```
- Object.assignメソッドはshallow copyする。ネストした先のオブジェクトまで複製するわけではない
- 

## JSON
- JavaScript Object Notationの略、JavaScriptのオブジェクトリテラルをベースに作られた軽量なデータ・フォーマット
- 人間にも読み書きが容易で、マシンにとっても簡単にパースや生成が行える
- オブジェクトリテラルのキーを必ずダブルクォートで囲まなければならない
- 外部プログラムとデータを交換する用途がほとんどで、データが常にJSONとして正しい保証がないため、JSON.parseメソッドは基本的にtry...catch構文で例外処理するべき
```javascript
try {
    const json = JSON.parse(userInput);
} catch (error) {
    console.log("パースできませんでした");
}
```
- JSON.stringify: オブジェクトをJSON文字列に
- JSON.parse: JSON文字列をオブジェクトに
- 両方ともtry...catch構文で安全に

## ECMASCriptモジュール
- 副作用のためのインポート
  - グローバルのコードを実行するだけで何もエクスポートしないものがある
  - これが、importしたら、勝手に実行された正体
```javascript
window.foo = "foo";
```
```javascript
// グローバルコードが実行される
import "./side-effects.js";
```
- type="module"を使うと、DOM構築後に実行する
- import export文を使うには必要な構文
- 強制strictモードになる


## ECMAScriptモジュール
- ES4の時に多くの変更を取り入れることを試みたが、最終的に合意できなかったからプロポーザル単位になった
- ステージ4となったプロポーザルはドラフト版であるGitHubの`tc39/ecma262`にマージされる。そして、毎年決まった時期に`ECMAScript 20XX`としてリリースされる
- ステージ3以下は`tc39/proposals`に載っているため、過程や最新の正確な情報を知りたい場合に参照する。
- ステージ4未満はまだ安定していない。
- 常に追うのも良いけど、調べたい時に知る手段を知っておくだけで違う
- 
## TODO
- [ ] Symbol何に使う
- [ ] ビルトインオブジェクト is 何

- [ ] プロトタイプチェーン
- [ ] strictモードに自動でなる条件

## 章
- [ ] プロトタイプオブジェクト
- [ ] 配列
- [ ] 文字列
- [ ] 文字列とUnicode
- [ ] ラッパーオブジェクト
- [ ] 関数とスコープ
- [ ] 関数とthis
- [ ] クラス
- [ ] 例外処理
- [ ] 非同期処理
- [ ] Map/Set
- [x] JSON
- [x] Date
- [x] Math
- [x] ECMAScriptモジュール
- [x] ECMAScript