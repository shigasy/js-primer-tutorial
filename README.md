# js-primer-tutorial

## 値の評価と表示
- ブラウザのREPLで`shift + enter`で複数行入力出来る。

- ウェブページリロードでREPLの実行状態をリセット
- 自動表示はREPLの機能
- // => 評価結果 という書き方は良さそう

## データ型とリテラル
- オブジェクト型とは、複数のプリミティブ型の値またはオブジェクトからなる集合のこと
- オブジェクト型は参照型
- typeof演算子はプリミティブ型とオブジェクト型かを判定するもの。オブジェクトの詳細な種類を判定できない
- "" や '' や `` はすべて文字列型。 ""や''は改行したい場合、\nが必要。テンプレートリテラルは\nが必要ない。
- リテラルとは、プログラム上で数値や文字列など、データ型の値を直接記述できるように構文として定義されたもの。 {}はオブジェクトリテラル -> オブジェクトとしてデータ型を定義できる
- undefinedはただのグローバル変数でundefinedという値を持っているだけ。true や false、 nullはリテラルであるため、同じ名前の変数を定義できない。
- オブジェクト型のドット記法は変数名と同じく識別子である必要があるため、数値から始める識別子は利用できない
- / /とスラッシュで囲むと正規表現リテラル。正規表現のデータ型になる。（オブジェクト）
- 明示的にラッパーオブジェクトを使う理由はない。JavaScriptではプリミティブ型のデータに対してもオブジェクトのように参照できる仕組みがあるから。（lengthプロパティにアクセスできる）
  - プリミティブ型のデータのプロパティにアクセスする際に、対応するラッパーオブジェクトへの暗黙的に変換してプロパティにアクセスするから。

## 演算子
- 演算子の対象のことを被演算子（オペランドと呼ぶ）オペランド1 演算子 オペランド2
- 単項演算子と二項演算子
- ** べき乗演算子はES2016から
- NaNはNot a Numberの略で数値ではないがNumber型を表現。NaNはどの値とも一致しない特性があり、Number.isNaNメソッドでNaNを判定できる
- インクリメント演算子
  - 前置の場合 num++
    1. numの評価結果を返す
    2. numに対して+1する
  - 後置の場合 ++num
    1. numに対して+1する
    2. numの評価結果を返す
- === 厳密等価演算子は同じ型で同じ値である場合にtrueを返す
  - オブジェクト同士の場合、参照が同じである場合にtrueを返す
- == 等価演算子はオペランド同士が異なる方の値であった場合に、同じ型となるように暗黙的な型変換をしてから比較するため、予測できない挙動が多く存在する。
- null と undefinedの比較の場合、 == で判定出来るため、1度の比較でよくなる。これは例外的なケースであるため、仕組みを理解するまでは常に厳密等価演算子を利用することを推奨。
- ~ 否定演算子は1の補数を返すため、~indexOfメソッドを使ったイディオムが一部では使われていた。
- 代入演算子は二項演算子と組み合わせて利用できる /= *= &=
- 論理演算子の短絡評価は便利だよね〜 x || y で xがtrueだったらyが評価されずにyを返すやつ。 && も似たような感じ。
- 安易に!!による返還に頼るより、明示的に出来る方法 str.length > 0 などにした方が可動性高まる

## 暗黙的な型変換
- Booleanコンストラクター関数を使うことで、任意の値をtrueまたはfalseの真偽値に変換できる。REPLでさっと検証できそう
- 暗黙的な型変換より、明示的な型変換
- 明示的に変換でも解決しないことがある（NaNなど） 例外処理や型を付けるなど解決策はある。そもそも受け付けなければOK
- 空文字判定など、型変換以外の方法もある（.length === 0）