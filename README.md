# js-primer-tutorial

## 値の評価と表示
- ブラウザのREPLで`shift + enter`で複数行入力出来る。

- ウェブページリロードでREPLの実行状態をリセット
- 自動表示はREPLの機能
- // => 評価結果 という書き方は良さそう

## データ型とリテラル
- オブジェクト型とは、複数のプリミティブ型の値またはオブジェクトからなる集合のこと
- オブジェクト型は参照型
- typeof演算子はプリミティブ型とオブジェクト型かを判定するもの。オブジェクトの詳細な種類を判定できない
- "" や '' や `` はすべて文字列型。 ""や''は改行したい場合、\nが必要。テンプレートリテラルは\nが必要ない。
- リテラルとは、プログラム上で数値や文字列など、データ型の値を直接記述できるように構文として定義されたもの。 {}はオブジェクトリテラル -> オブジェクトとしてデータ型を定義できる
- undefinedはただのグローバル変数でundefinedという値を持っているだけ。true や false、 nullはリテラルであるため、同じ名前の変数を定義できない。
- オブジェクト型のドット記法は変数名と同じく識別子である必要があるため、数値から始める識別子は利用できない
- / /とスラッシュで囲むと正規表現リテラル。正規表現のデータ型になる。（オブジェクト）
- 明示的にラッパーオブジェクトを使う理由はない。JavaScriptではプリミティブ型のデータに対してもオブジェクトのように参照できる仕組みがあるから。（lengthプロパティにアクセスできる）
  - プリミティブ型のデータのプロパティにアクセスする際に、対応するラッパーオブジェクトへの暗黙的に変換してプロパティにアクセスするから。

## 演算子
- 演算子の対象のことを被演算子（オペランドと呼ぶ）オペランド1 演算子 オペランド2
- 単項演算子と二項演算子
- ** べき乗演算子はES2016から
- NaNはNot a Numberの略で数値ではないがNumber型を表現。NaNはどの値とも一致しない特性があり、Number.isNaNメソッドでNaNを判定できる
- インクリメント演算子
  - 前置の場合 num++
    1. numの評価結果を返す
    2. numに対して+1する
  - 後置の場合 ++num
    1. numに対して+1する
    2. numの評価結果を返す
- === 厳密等価演算子は同じ型で同じ値である場合にtrueを返す
  - オブジェクト同士の場合、参照が同じである場合にtrueを返す
- == 等価演算子はオペランド同士が異なる方の値であった場合に、同じ型となるように暗黙的な型変換をしてから比較するため、予測できない挙動が多く存在する。
- null と undefinedの比較の場合、 == で判定出来るため、1度の比較でよくなる。これは例外的なケースであるため、仕組みを理解するまでは常に厳密等価演算子を利用することを推奨。
- ~ 否定演算子は1の補数を返すため、~indexOfメソッドを使ったイディオムが一部では使われていた。
- 代入演算子は二項演算子と組み合わせて利用できる /= *= &=
- 論理演算子の短絡評価は便利だよね〜 x || y で xがtrueだったらyが評価されずにyを返すやつ。 && も似たような感じ。
- 安易に!!による返還に頼るより、明示的に出来る方法 str.length > 0 などにした方が可動性高まる

## 暗黙的な型変換
- Booleanコンストラクター関数を使うことで、任意の値をtrueまたはfalseの真偽値に変換できる。REPLでさっと検証できそう
- 暗黙的な型変換より、明示的な型変換
- 明示的に変換でも解決しないことがある（NaNなど） 例外処理や型を付けるなど解決策はある。そもそも受け付けなければOK
- 空文字判定など、型変換以外の方法もある（.length === 0）

## 関数と宣言
- ES2015でデフォルと引数が導入されるまでは、OR演算子を使ったデフォルト値の指定がよく利用されていた prefix || "デフォルト"
  - ただし、falsyな値の場合、デフォルト値になるため、""（空文字列）を指定した場合にもデフォルト値が入る。意図した挙動なのかわかりにくくなる
  - デフォルト引数は、引数が渡されなかった場合のみデフォルト値が入る
- Rest parameters（残余引数） function fn(...args)  に配列を展開して関数の引数に渡すSpread構文もある fn(...array)
- 可変用引数を実現したい時にarguments変数よりRest parametersでの実装を推奨
- 関数の引数においても分割代入が利用できる。これ初見読めなかった。
```javascript
const user = {
  id: 42
};
function printUserId({ id }) {
  console.log(id)
}
printUserId(user)
```
- 関数の引数における分割代入は、オブジェクトだけでなく配列についても利用できる
```javascript
function print([first, second]){

}
const array = [1, 2]
print(array)
```
- 関数はオブジェクトの1種。ただのオブジェクトと異なり、関数名に（）をつけることで、関数としてまとめた処理を呼び出せる。オブジェクトであるため、定義した関数を変数へ代入できる。関数が値として扱えることを第一級関数（ファーストクラスファンクション）と呼ぶ。
- 関数式とは、関数を値として代入している式の事。関数宣言は文だったが、関数式では関数を値として扱っている。
- Arrow Functionの特徴
  - thisが静的
  - 常に匿名関数（functionの関数式の場合、名前をつけられて、再帰的な処理も書くことができる）
  - arguments変数を参照できない
  - functionキーワードに比べて短く書くことが出来る
  - newできない（コンストラクタ関数ではない）
- Arrow Functionはfunctionキーワードと比べて、thisの問題を多く解決したり、arguments変数が使えないため、人による解釈や実装の違いが生まれにくいため、問題ない場合はArrow Functionで書くことを推奨。
- 同じ名前の関数宣言は上書きされる。varと同じ。これはJavaScriptの巻き上げによるものだと思う。同じ名前にすることは基本的に避けるべきであり、引数の数で関数を分けたい場合は、別々の名前 or 関数内部で引数の処理を分岐
- ES2015からメソッドの短縮記法がある。オブジェクトリテラルの中でメソッド名() {} と書くことが出来る
```javascript
const obj = {
  method() {
    return 'this is method';
  }
}
console.log(obj.method())
```
- 関数文と関数式の違いは巻き上げの有無と匿名関数が可能くらいかな。コールバック関数として関数文も使えたし。
- functionキーワードとArrow functionは割と違う

## 文と式
- 式とは、値を生成し、変数に代入できるもの
- 文とは、処理する1ステップが1つの文

- ブロック文を使うと、REPLで試行錯誤しやすい（スコープが限定されるため、同じ変数でconst let宣言できる）
- JavaScriptは文（Statement）と式（Expression）から構成される
- 文は式になれない（if文や関数宣言は変数に入れられない（関数式は別））
- 式は文になれる（式文）
- 式の末尾にはセミコロン
- 文の処理の一部として式を含むことがある（if文の条件の所は式）
- ブロックで終わる文は例外的にセミコロンをつけなくてよい

## 条件分岐
- 1行のときのみ {} ブロック省略できるが、どこまでがif文かが分かりにくくなるため、常にブロックで囲むことを推奨
- if文の条件式にtrueまたはfalseといった真偽値以外の値も指定可能。真偽値以外の値の場合、暗黙的に真偽値に変換して条件式で判定
- break;を忘れると意図しないcase節が実行されてしまうため、多用されているswitch文が出てきた場合、別の方法で書けないかを考えるべきサイン。returnを返すパターンが多い。（break要らない）
- 